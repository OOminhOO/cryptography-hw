# 암호학 기본 개념 정리
## 암호화란?
-암호화란 정보를 보호하기 위해 평문(원본 데이터)을 특정 알고리즘을 통해 암호문(이해할 수 없는 형태)으로 변환하는 과정이다.  
암호에 대해서 가장 중요한 것은 기밀성을 제공하는 것이다.  
현대 사용하는 암호화 방식에는 대칭 암호화, 비대칭 암호화, 해쉬 크게 3가지가 있다.  

<br>

## 보안의 4대 속성(CIAA) , 무결성 (Integrity), 인증 (Authentication), 부인방지 (Non-repudiation)  
### 기밀성 (Confidentiality)**  
정의: 인가되지 않은 사용자가 정보를 열람할 수 없게 하는 것.  

목적: 정보의 노출 방지.  

수단: 암호화, 접근 제어, 키 관리.   

예시: 암호화되지 않은 저장소에 키파일을 두면 기밀성 위반.  

하드웨어 예시: FPGA 내부에 고정된 비밀키(eFUSE, OTP)에 저장 → 외부에서 읽기 불가.  
<br>
### 무결성 (Integrity)
정의: 데이터가 전송되거나 저장되는 동안 변조되지 않았음을 보장하는 것.  

목적: 데이터의 정확성과 신뢰성 유지.  

수단: 해시(Hash), MAC, 디지털 서명, CRC.  

예시: SD카드에 저장된 암호문이 일부 손상됐는데, 검증 단계가 없으면 잘못된 복호화 결과가 나옴.  

하드웨어 예시: 복호화 직전 해시값 비교 블록 삽입 → 변조 여부 확인.  
<br>
### 인증 (Authentication)  
정의: 통신 상대방이나 데이터의 출처를 확인하는 과정.  

목적: “누가 보냈는가” “진짜 장치인가”를 검증.  

수단: 패스워드, 디지털 서명, 인증서, 챌린지-응답 프로토콜.  

예시: 공격자가 가짜 센서나 외부 장치를 연결해 데이터를 보내도 시스템이 속지 않게 함.  

하드웨어 예시: FPGA–MCU 간 통신 시 디지털 서명 기반 인증 절차 추가.  
<br>
### 부인방지 (Non-repudiation)
정의: 통신이나 행위를 수행한 당사자가 나중에 부인하지 못하도록 하는 것.  

목적: 책임 추적성 확보(“누가, 언제, 무엇을 했는가”).  

수단: 전자서명, 로그 무결성, 타임스탬프.  

예시: 사용자가 이미지 전송 후 “난 안 보냈다”고 주장해도 서명으로 증명 가능.  

하드웨어 예시: 보안 로그를 서명과 함께 저장하거나, TPM·Secure Element에 저장.    

---
## 대칭키 암호화

대칭키 암호화는 **암호화와 복호화에 동일한 키를 사용**하는 방식으로, 일반적인 자물쇠와 열쇠의 관계와 유사하다. 하나의 열쇠로 자물쇠를 잠그고 같은 열쇠로 여는 것처럼, 하나의 비밀키로 데이터를 암호화하고 같은 키로 복호화한다. 비대칭키 암호화에 비해 알고리즘이 단순하여 CPU 리소스 소모가 적고 처리 속도가 빠른 장점이 있다. 대표적인 알고리즘에는 **DES, AES, SEED, ARIA** 등의 있다.  
암호화 실습(AES)
 
아래 사이트는 다양한 암호 기법을 실습해 볼 수 있는 사이트이다.  
https://emn178.github.io/online-tools/aes/decrypt/  
<br>

## 비대칭키 암호화
대칭키 암호화는 **암호화와 복호화에 서로 다른 키를 사용**하는 방식이다. 키페어(한 쌍) 즉, 하나의 키로 암호화하면 다른 하나의 키로 복호화할 수 있는 특징이 있다. 송신자는 수신자의 공개된 **공개키를 가지고 암호화**하여 데이터를 보내면, **개인키를 가지고 있는 수신자만이 복호화**할 수 있다. 대표적인 알고리즘으로는 **RSA 방식**이 존재한다.  
 
왜 이렇게 복잡하게 암호화를 해야 할까? 그 이유는 바로 대칭키 방식의 한계를 극복하기 위함이다. 대칭키 방식은 암복호화 시, 동일한 키를 사용하기 때문에, 키를 교환하는 과정에서 원하지 않는 사람에게 키가 노출될 수 있다.(키노출사고)  
 
하지만, 그렇다고 해서 비대칭키 암호화가 장점만 존재하는 것은 아니다. 보안성이 뛰어난 만큼, 복잡한 로직(수학적 연산)으로 인해 대칭키 암호화보다 리소스 소모가 훨씬 크다. 그래서 실제 통신 환경에서는 두 방식을 효율적으로 조합하여 사용한다. SSL/TLS와 같은 보안 프로토콜에서의 경우 초기 연결 설정(핸드세이크) 단계에서만 비대칭키 암호화를 사용하여 안전하게 PMS(Pre-Master Secret)라는 임시 대칭키를 교환하고, 이후 실제 데이터 통신은 이 PMS를 기반으로 생성된 세션 키(대칭키)를 사용하여 암호화한다.  

<br>

## HASH 함수  
해시 함수는 **임의 길이의 데이터를 고정된 길이의 값으로 변환하는 단방향 암호화 기술**이다. 단방향이라는 것은 원본 데이터를 **암호화할 수는 있지만, 복호화할 수는 없다**는 의미이다. 이러한 단방향 암호의 주요 목적은 정보 은닉이 아닌, **데이터 무결성을 검증**하기 위함이다.
 
해시 함수는 **원본데이터를 조금이라도 변경하면, 출력되는 암호화 값이 아예 달라지므로**, 원본 데이터를 추측할 수 없게 한다. 해시 함수는 데이터 무결성 검증에 이상적이지만, 치명적인 보안적 취약점도 존재한다.
 
해시 함수의 특성상 동일한 입력에는 항상 동일한 출력값이 생성되므로, 공격자가 미리 계산된 해시값 목록(레인보우 테이블)을 구축하여 역으로 원본 데이터를 찾아낼 수 있다. 이러한 취약점을 해결하기 위해 대표적으로는 솔트(Salt) 기법이 적용된다. 솔트는 해시하기 전 원본 데이터에 임의의 값을 추가하여 동일한 입력이라도 다른 해시값이 생성되게 한다.
 
이러한 무차별 대입공격과 레인보우 테이블 공격에 대응하기 위해서는 보다 강력한 해시 알고리즘을 사용하는 것이 중요하다. 실제로 대부분 보안 표준 기관들은 MD5, SHA-1과 같은 취약한 알고리즘 대신, SHA-256, SHA-512 같은 강력한 해시 알고리즘을 사용하도록 권고한다.

<br>

## 메시지 인증 : 메시지의 무결성  
메시지 인증은 데이터 전송 과정에서 **원본 데이터의 무결성을 보장**하기 위한 기술이다.  보낸 사용자의 원본 데이터가 변경되지 않았는지를 검증하기 위해 (원본데이터 + 해시 함수)를 더해 보낸다.
 
하지만, 해시 함수만 사용할 경우 중간자 공격에 취약하기 때문에, **HMAC(Hash-based Message Authentication Code)** 이라는 보다 안전한 방식이 사용된다. HMAC은 메시지와 비밀키를 함께 해시 함수(원본데이터 + 해시 함수 + 비밀키)에 입력하여 인증 코드를 생성함으로써 메시지의 무결성과 송신자 인증을 동시에 제공한다. 송신자와 수신자만이 공유하는 비밀키를 사용하기 때문에, 키를 모르는 제3자는 유효한 HMAC 값을 생성할 수 없다. HMAC-MD5, HMAC-SHA256 등 다양한 해시 알고리즘과 조합하여 사용할 수 있으며, SSL/TLS, IPsec, VPN 등 많은 보안 프로토콜에서 메시지 인증을 위해 널리 활용된다.  

<br> 

## 디지털 서명 : 부인봉쇄의 필요성  
디지털 서명은 메시지 인증의 한계를 넘어 부인방지(non-repudiation) 기능을 제공하는 암호화 기술이다. HMAC이 메시지 무결성을 검증할 수 있지만, 송신자와 수신자가 동일한 비밀키를 공유하기 때문에 누가 메시지를 생성했는지 제3자가 확인할 수 없다는 한계가 존재한다.  

```
부인방지(non-repudiation)는 디지털 서명을 통해 송신자가 자신의 개인키로 메시지에 서명함으로써,
나중에 해당 메시지를 보냈다는 사실을 부인할 수 없도록 하는 보안 기능이다.
```

디지털 서명은 이 문제를 해결하기 위해 비대칭키 암호화의 특성을 활용한다. 송신자는 자신의 개인키(오직 본인만 소유)로 데이터를 암호화하여 서명을 생성하고, 수신자는 송신자의 공개키로 이 서명을 복호화하여 검증합니다. 이 과정을 통해 해당 메시지가 개인키 소유자에 의해 작성되었음을 증명할 수 있으며, 송신자는 나중에 메시지 전송 사실을 부인할 수 없게 됩니다.  
 
일반적으로 비대칭키 암호화에서 공개키를 이용하여 암호화하였다면 반대로 개인키를 가지고 암호화하여 자신의 신원을 보장한다는 것이 큰 특징이다. ( 계약서의 싸인 및 서명하는 것처럼, 자신의 개인키를 가지고 전자서명을 생성한다.)  
이러한 디지털 서명, 즉 전자서명 값을 시그니처(Signature)라고 한다.  

## X.509 & PKI
**X.509와 PKI(Public Key Infrastructure)** 는 현대 인터넷 보안의 핵심 요소로, 디지털 인증서와 공개키 암호화를 통해 안전한 보안 통신을 가능하게 한다.  
 
**X.509는 디지털 인증서의 표준 형식**이며, 인증서 소유자의 신원, 공개키, 유효기간, 발급자 정보 등을 포함한다. 이 표준화된 형식을 통해 다양한 시스템과 애플리케이션 간의 호환성을 보장한다.  
 
PKI(Public Key Infrastructure)는 이러한 디지털 인증서를 생성, 관리, 배포하는 전체 시스템과 인프라를 의미한다.  
PKI의 특징은 다음과 같다.  

PKI는 기본적으로 RSA 암호화 알고리즘을 사용한다.  
인증서 발급자(ISSUER)는 인증기관(CA, Certificate Authority)이다.  
CA가 자신의 개인키로 서명하여 스스로 인증한 인증서를 루트 인증서라고 한다.  
제3의 공인된 인증기관을 통해 공개키 배포의 신뢰성 문제를 해결한다.  
정리하자면, PKI의 주요 목적은 X.509라는 표준화된 인증서 형식을 활용하여 CA라는 인증 기관을 통해서 사용자의 공개키를 신뢰성 있게 배포하기 위한 환경을 제공하는 것이다.  
 
 
실제 구현에서는 RSA와 같은 알고리즘이 대용량 데이터 암호화에 비효율적이므로, 메시지 전체가 아닌 해시값만 암호화하는 방식을 사용합니다.  





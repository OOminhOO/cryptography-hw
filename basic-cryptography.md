#  암호학 기본 개념 정리 (IoT/엣지 초급용) + 경량암호 & PRESENT 한눈에 보기
## 암호화란?
-암호화란 정보를 보호하기 위해 평문(원본 데이터)을 특정 알고리즘을 통해 암호문(이해할 수 없는 형태)으로 변환하는 과정이다.  
암호에 대해서 가장 중요한 것은 기밀성을 제공하는 것이다.  
현대 사용하는 암호화 방식에는 대칭 암호화, 비대칭 암호화, 해쉬 크게 3가지가 있다.  

<br>

## 보안의 4대 속성(CIAA) , 무결성 (Integrity), 인증 (Authentication), 부인방지 (Non-repudiation)  
### 기밀성 (Confidentiality)**  
정의: 인가되지 않은 사용자가 정보를 열람할 수 없게 하는 것.  

목적: 정보의 노출 방지.  

수단: 암호화, 접근 제어, 키 관리.   

예시: 암호화되지 않은 저장소에 키파일을 두면 기밀성 위반.  

하드웨어 예시: FPGA 내부에 고정된 비밀키(eFUSE, OTP)에 저장 → 외부에서 읽기 불가.  
<br>
### 무결성 (Integrity)
정의: 데이터가 전송되거나 저장되는 동안 변조되지 않았음을 보장하는 것.  

목적: 데이터의 정확성과 신뢰성 유지.  

수단: 해시(Hash), MAC, 디지털 서명, CRC.  

예시: SD카드에 저장된 암호문이 일부 손상됐는데, 검증 단계가 없으면 잘못된 복호화 결과가 나옴.  

하드웨어 예시: 복호화 직전 해시값 비교 블록 삽입 → 변조 여부 확인.  
<br>
### 인증 (Authentication)  
정의: 통신 상대방이나 데이터의 출처를 확인하는 과정.  

목적: “누가 보냈는가” “진짜 장치인가”를 검증.  

수단: 패스워드, 디지털 서명, 인증서, 챌린지-응답 프로토콜.  

예시: 공격자가 가짜 센서나 외부 장치를 연결해 데이터를 보내도 시스템이 속지 않게 함.  

하드웨어 예시: FPGA–MCU 간 통신 시 디지털 서명 기반 인증 절차 추가.  
<br>
### 부인방지 (Non-repudiation)
정의: 통신이나 행위를 수행한 당사자가 나중에 부인하지 못하도록 하는 것.  

목적: 책임 추적성 확보(“누가, 언제, 무엇을 했는가”).  

수단: 전자서명, 로그 무결성, 타임스탬프.  

예시: 사용자가 이미지 전송 후 “난 안 보냈다”고 주장해도 서명으로 증명 가능.  

하드웨어 예시: 보안 로그를 서명과 함께 저장하거나, TPM·Secure Element에 저장.    

---
## 대칭키 암호화

대칭키 암호화는 **암호화와 복호화에 동일한 키를 사용**하는 방식으로, 일반적인 자물쇠와 열쇠의 관계와 유사하다. 하나의 열쇠로 자물쇠를 잠그고 같은 열쇠로 여는 것처럼, 하나의 비밀키로 데이터를 암호화하고 같은 키로 복호화한다. 비대칭키 암호화에 비해 알고리즘이 단순하여 CPU 리소스 소모가 적고 처리 속도가 빠른 장점이 있다. 대표적인 알고리즘에는 **DES, AES, SEED, ARIA** 등의 있다.  
암호화 실습(AES)
 
아래 사이트는 다양한 암호 기법을 실습해 볼 수 있는 사이트이다.  
https://emn178.github.io/online-tools/aes/decrypt/  
<br>

## 비대칭키(공개) 암호화
대칭키 암호화는 **암호화와 복호화에 서로 다른 키를 사용**하는 방식이다. 키페어(한 쌍) 즉, 하나의 키로 암호화하면 다른 하나의 키로 복호화할 수 있는 특징이 있다. 송신자는 수신자의 공개된 **공개키를 가지고 암호화**하여 데이터를 보내면, **개인키를 가지고 있는 수신자만이 복호화**할 수 있다. 대표적인 알고리즘으로는 **RSA 방식**이 존재한다.  
 
왜 이렇게 복잡하게 암호화를 해야 할까? 그 이유는 바로 대칭키 방식의 한계를 극복하기 위함이다. 대칭키 방식은 암복호화 시, 동일한 키를 사용하기 때문에, 키를 교환하는 과정에서 원하지 않는 사람에게 키가 노출될 수 있다.(키노출사고)  
 
하지만, 그렇다고 해서 비대칭키 암호화가 장점만 존재하는 것은 아니다. 보안성이 뛰어난 만큼, 복잡한 로직(수학적 연산)으로 인해 대칭키 암호화보다 리소스 소모가 훨씬 크다. 그래서 실제 통신 환경에서는 두 방식을 효율적으로 조합하여 사용한다. SSL/TLS와 같은 보안 프로토콜에서의 경우 초기 연결 설정(핸드세이크) 단계에서만 비대칭키 암호화를 사용하여 안전하게 PMS(Pre-Master Secret)라는 임시 대칭키를 교환하고, 이후 실제 데이터 통신은 이 PMS를 기반으로 생성된 세션 키(대칭키)를 사용하여 암호화한다.  

<br>

## HASH 함수  
해시 함수는 **임의 길이의 데이터를 고정된 길이의 값으로 변환하는 단방향 암호화 기술**이다. 단방향이라는 것은 원본 데이터를 **암호화할 수는 있지만, 복호화할 수는 없다**는 의미이다. 이러한 단방향 암호의 주요 목적은 정보 은닉이 아닌, **데이터 무결성을 검증**하기 위함이다.
 
해시 함수는 **원본데이터를 조금이라도 변경하면, 출력되는 암호화 값이 아예 달라지므로**, 원본 데이터를 추측할 수 없게 한다. 해시 함수는 데이터 무결성 검증에 이상적이지만, 치명적인 보안적 취약점도 존재한다.
 
해시 함수의 특성상 동일한 입력에는 항상 동일한 출력값이 생성되므로, 공격자가 미리 계산된 해시값 목록(레인보우 테이블)을 구축하여 역으로 원본 데이터를 찾아낼 수 있다. 이러한 취약점을 해결하기 위해 대표적으로는 솔트(Salt) 기법이 적용된다. 솔트는 해시하기 전 원본 데이터에 임의의 값을 추가하여 동일한 입력이라도 다른 해시값이 생성되게 한다.
 
이러한 무차별 대입공격과 레인보우 테이블 공격에 대응하기 위해서는 보다 강력한 해시 알고리즘을 사용하는 것이 중요하다. 실제로 대부분 보안 표준 기관들은 MD5, SHA-1과 같은 취약한 알고리즘 대신, SHA-256, SHA-512 같은 강력한 해시 알고리즘을 사용하도록 권고한다.

<br>

## 메시지 인증 : 메시지의 무결성  
메시지 인증은 데이터 전송 과정에서 **원본 데이터의 무결성을 보장**하기 위한 기술이다.  보낸 사용자의 원본 데이터가 변경되지 않았는지를 검증하기 위해 (원본데이터 + 해시 함수)를 더해 보낸다.
 
하지만, 해시 함수만 사용할 경우 중간자 공격에 취약하기 때문에, **HMAC(Hash-based Message Authentication Code)** 이라는 보다 안전한 방식이 사용된다. HMAC은 메시지와 비밀키를 함께 해시 함수(원본데이터 + 해시 함수 + 비밀키)에 입력하여 인증 코드를 생성함으로써 메시지의 무결성과 송신자 인증을 동시에 제공한다. 송신자와 수신자만이 공유하는 비밀키를 사용하기 때문에, 키를 모르는 제3자는 유효한 HMAC 값을 생성할 수 없다. HMAC-MD5, HMAC-SHA256 등 다양한 해시 알고리즘과 조합하여 사용할 수 있으며, SSL/TLS, IPsec, VPN 등 많은 보안 프로토콜에서 메시지 인증을 위해 널리 활용된다.  

<br> 

## 디지털 서명 : 부인봉쇄의 필요성  
디지털 서명은 메시지 인증의 한계를 넘어 부인방지(non-repudiation) 기능을 제공하는 암호화 기술이다. HMAC이 메시지 무결성을 검증할 수 있지만, 송신자와 수신자가 동일한 비밀키를 공유하기 때문에 누가 메시지를 생성했는지 제3자가 확인할 수 없다는 한계가 존재한다.  

```
부인방지(non-repudiation)는 디지털 서명을 통해 송신자가 자신의 개인키로 메시지에 서명함으로써,
나중에 해당 메시지를 보냈다는 사실을 부인할 수 없도록 하는 보안 기능이다.
```

디지털 서명은 이 문제를 해결하기 위해 비대칭키 암호화의 특성을 활용한다. 송신자는 자신의 개인키(오직 본인만 소유)로 데이터를 암호화하여 서명을 생성하고, 수신자는 송신자의 공개키로 이 서명을 복호화하여 검증합니다. 이 과정을 통해 해당 메시지가 개인키 소유자에 의해 작성되었음을 증명할 수 있으며, 송신자는 나중에 메시지 전송 사실을 부인할 수 없게 됩니다.  
 
일반적으로 비대칭키 암호화에서 공개키를 이용하여 암호화하였다면 반대로 개인키를 가지고 암호화하여 자신의 신원을 보장한다는 것이 큰 특징이다. ( 계약서의 싸인 및 서명하는 것처럼, 자신의 개인키를 가지고 전자서명을 생성한다.)  
이러한 디지털 서명, 즉 전자서명 값을 시그니처(Signature)라고 한다.  

## X.509 & PKI
**X.509와 PKI(Public Key Infrastructure)** 는 현대 인터넷 보안의 핵심 요소로, 디지털 인증서와 공개키 암호화를 통해 안전한 보안 통신을 가능하게 한다.  
 
**X.509는 디지털 인증서의 표준 형식**이며, 인증서 소유자의 신원, 공개키, 유효기간, 발급자 정보 등을 포함한다. 이 표준화된 형식을 통해 다양한 시스템과 애플리케이션 간의 호환성을 보장한다.  
 
PKI(Public Key Infrastructure)는 이러한 디지털 인증서를 생성, 관리, 배포하는 전체 시스템과 인프라를 의미한다.  
PKI의 특징은 다음과 같다.  

PKI는 기본적으로 RSA 암호화 알고리즘을 사용한다.  
인증서 발급자(ISSUER)는 인증기관(CA, Certificate Authority)이다.  
CA가 자신의 개인키로 서명하여 스스로 인증한 인증서를 루트 인증서라고 한다.  
제3의 공인된 인증기관을 통해 공개키 배포의 신뢰성 문제를 해결한다.  
정리하자면, PKI의 주요 목적은 X.509라는 표준화된 인증서 형식을 활용하여 CA라는 인증 기관을 통해서 사용자의 공개키를 신뢰성 있게 배포하기 위한 환경을 제공하는 것이다.  
 
 
실제 구현에서는 RSA와 같은 알고리즘이 대용량 데이터 암호화에 비효율적이므로, 메시지 전체가 아닌 해시값만 암호화하는 방식을 사용합니다.  

## 6) IoT/엣지에서 무엇을 쓸까? (의사결정 가이드)
- **기본 선택(AEAD)**  
  - **ASCON-AEAD128**: NIST 경량암호 표준(2025, SP 800-232). 저자원 장치에서 **작은 코드/메모리**와 태그 인증 제공.  
  - **AES-GCM**: 보드에 **AES 하드웨어 가속**이 있으면 여전히 강력한 선택.
- **블록 암호 CTR만 우선 쓰는 기능검증**(태그 생략): **IV/nonce 재사용 금지**를 문서화·검증할 것.
- **키 관리**: 프로토타입은 임시 로딩, 제품화는 **eFUSE/OTP/SE/PUF** 중 택1.
- **TRNG/DRBG**: IV/nonce·마스킹에 필요. 보드의 RNG 품질 확인.

---

## 6) 블록 암호 운용 모드 (ECB / CBC / CTR / GCM)

| 모드 | 개념 | 장점 | 단점/주의 | 쓰임새 |
|---|---|---|---|---|
| **ECB** | 블록 독립 변환 | 구현 간단 | **패턴 노출** → 사실상 금지 | 학습/디버그 한정 |
| **CBC** | 이전 블록과 체인 + 랜덤 IV | 간단, 과거 표준 | **직렬화**, 패딩 필요, **무결성 없음** | 레거시 호환 |
| **CTR** | `KS = E(K, nonce||ctr)`, 스트림화 | 병렬화, 패딩X, 간단 | **malleable**, **nonce 재사용 금지**, MAC 필요 | 임베디드/FPGA 적합 |
| **GCM** | CTR + GHASH(태그) | **AEAD**(무결성 포함), 병렬화 | **nonce 재사용 금지**(치명적) | 범용 표준 |

> **IV/nonce 규칙**: 각 (키, nonce) 조합 **단 한 번**만 사용. GCM은 **96비트 IV** 권장.

---

## 7) AEAD (Authenticated Encryption with Associated Data)
**기밀성 + 무결성(인증 태그)** 동시 제공. AAD(헤더 등)는 암호화하지 않고 태그에만 포함.
- **대표**: **AES-GCM**, **CCM**, **ChaCha20-Poly1305**, **ASCON-AEAD**(경량 표준 계열)
- **장점**: 암호화/검증 한 번에, 구현 실수 감소
- **주의**: **(키, nonce) 재사용 금지**. 재사용 시 기밀성·무결성 모두 붕괴

---

## 8) 스트림 암호 vs 블록 암호
- **스트림 암호**: 키스트림 `KS` 생성 후 `C = P ⊕ KS`  
  - 장점: 지연 적음, 패딩 불필요, 바이트/비트 단위 처리  
  - 주의: **같은 (키, nonce)** 재사용 → 원문 누설  
  - 예: ChaCha20 (*블록암호 CTR 운용은 사실상 스트림처럼 동작*)
- **블록 암호**: 고정 블록(예: 64/128b) 단위 변환 → **모드**로 스트림화  
  - 장점: 표준/분석 풍부, HW 구현 용이  
  - 주의: **블록 크기 생일한계**: n-비트 블록이면 약 **2^(n/2)** 블록 수준에서 충돌 위험

---

## 9) Feistel vs SPN (Substitution-Permutation Network)

| 구분 | 구조 | 복호화 | 대표 |
|---|---|---|---|
| **Feistel** | 입력을 L/R로 나눠 `Lᵢ₊₁ = Rᵢ`, `Rᵢ₊₁ = Lᵢ ⊕ F(Rᵢ, Kᵢ)` | **같은 F**, **키 순서 역순** | **DES**, **SIMON**, **SIMECK/SPECK** |
| **SPN** | **S-box(비선형)** → **선형 확산(P)** 반복 | **역 S-box/역 선형층** 필요 | **AES**, **PRESENT**, **PIPO** |

- **HW 관점**  
  - Feistel: 복호가 쉽다(라운드 역함수 불필요), F 설계가 핵심  
  - SPN: **병렬 S-box + 고정 배선**으로 파이프라인/직렬화 선택 폭 큼

---

## 10) 부채널 공격(측면 채널) — 개념/대응
**개념**: 수학적 취약점이 아닌 **전력·시간·EM(전자파)·Fault** 등 물리적 누설로 키를 추정.
- **최소 대응(프로토타입)**: **상수 시간화**(분기 제거/루프 일정), **메모리 접근 패턴 고정**, **nonce 재사용 금지**
- **강화(제품)**: **마스킹(1st-order↑)**, 셔플링/디-동기화, 난수 주입, 전력 평탄화/차폐, **Fault 검출**(이중 계산·체크태그)
- **평가**: TVLA(t-test) 등 통계 시험으로 누설 유무 점검

---



## 7) 경량암호(Lightweight Crypto) 개요
**제약(면적/전력/메모리/지연)** 환경에 맞춘 대칭·AEAD·해시들. 설계 트레이드오프:
- 작은 S-box/간단 전치, 직렬화(면적↓) vs 파이프라인(처리량↑), 상태크기 최소화.
- **부채널** 대응(마스킹/타이밍 균일화) 고려.

---

## 8) 블록암호·AEAD 간단 소개 (IoT 관점)

- **PRESENT** — *경량 블록암호 (SPN)*  
  64-bit 블록, 80/128-bit 키, **31라운드**. 4-bit S-box ×16 + 비트 전치 P-레이어. HW 면적/전력 매우 작다. (아래 상세)  
- **SIMON / SIMECK** — *경량 블록암호 (Feistel/ARX)*  
  하드웨어 친화적 회전·AND·XOR로 구성. 다양한 블록/키 크기 변종이 있어 임베디드에 맞춰 선택.  
- **ASCON** — *경량 **AEAD/해시***  
  **블록암호가 아니라** 순열기반 스펀지 구조. **AEAD(태그)**와 해시/XOF 제공. NIST 경량암호 표준(2025).  
- **국산 예시** — *LEA/CHAM/HIGHT/PIPO*  
  임베디드 최적화 설계 자료가 풍부, HW 구현 레퍼런스 다수.

> 참고: 블록암호는 **모드(CTR/GCM/CCM 등)**로 운용해야 파일/스트림을 처리 가능. AEAD는 태그 포함으로 **무결성**까지.

---

## 9) PRESENT 한 장 요약 (구조·이점·주의)
- **파라미터**: 블록 64b, 키 80/128b, **31 라운드**, 최종 **AddRoundKey**(포스트 화이트닝).  
- **라운드**:  
  1) `AddRoundKey` (64b ⊕ 라운드키) →  
  2) `S-box Layer` (4b S-box 16개 병렬 적용) →  
  3) `Permutation Layer` (비트 위치 전치).  
- **키스케줄**: 라운드 상수 추가 + 회전/치환으로 라운드키 생성(PRESENT-80/128 차이 존재).  
- **장점**: **소면적/저전력**(직렬화 구현 용이), 단순 구조 → RTL 분해 쉬움.  
- **주의**: **64-bit 블록**은 대용량 스트림에서 **생일한계**가 빨리 온다. CTR/CFB 등 운용 시 **nonce/카운터 관리**를 철저히 하고, AEAD를 쓰면 더 안전.

---

## 10) HW 구현의 이득과 함정 (SoC/FPGA 관점)

**이득**
- 파이프라인/병렬화로 **고처리량·저지연**, 소프트웨어 대비 **에너지/성능 우수**, 펌웨어 노출 감소.

**함정**
- **부채널 공격**(전력/EM/타이밍/글리치) 취약:  
  - 초기: **타이밍 균일화**, 분기/메모리 패턴 고정.  
  - 개선: **마스킹/블라인딩**, 난수 주입, 전력 평탄화.  
- 키 보관/업데이트: eFUSE/OTP는 **불가역**, SE/TPM은 BOM/통합 부담.

---

## 11) PRESENT RTL 시작 체크리스트 (기능검증용)

- **모듈 분해**: `present_core`(1라운드) / `key_schedule` / `round_ctrl` / `ctr_wrapper`(선택).  
- **데이터 경로**: 64b 상태 레지스터 ↔ S-box(16×4b) ↔ P-레이어 비트 셔플.  
- **라운드 제어**: 31회 반복 + **마지막 AddRoundKey**.  
- **CTR 래퍼**(옵션): 64b nonce||counter → **재사용 금지**, 블록마다 counter++.  
- **검증**: 공개 **테스트벡터**로 블록·스트림 확인 → 파일 round-trip 테스트(평문→암→복호 동일).  
- **초기 보안 위생**: 조건문 분기 제거, 고정 지연 파이프라인, IV/nonce 기록.

---

## 12) 빠른 선택 가이드 (요약)
- **AEAD 필요(무결성 포함)**: **ASCON-AEAD128**(저자원) 또는 **AES-GCM**(HW 가속 시).  
- **기능검증(암복호만)**: **PRESENT-CTR**(간단/저자원) → IV/nonce 재사용 금지.  
- **키보관**: 프로토타입 임시 로딩 → 제품화 시 **eFUSE/OTP/SE/PUF**로 이관.

---

## 참고/추가읽기(한글 위주)
- **KISA 암호 키 관리 안내서** — 키 수명주기·보관·폐기 가이드.  
- **KISA 부채널 공격 취약성 평가방법론** — 전력/EM/타이밍 공격과 대응.  
- **PRESENT 구조/라운드/키스케줄** — 한글 특허/논문 요약.  
- **SIMON/SIMECK 개요(경량 블록암호)** — 한글 논문/요약.  
- **NIST SP 800-232 (2025)** — **ASCON 기반 경량암호 표준**(AEAD/Hash/XOF).






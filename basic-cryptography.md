# 암호학 기본 개념 정리 (IoT/엣지 초급용) + 경량암호 & PRESENT 한눈에 보기

> 목표: 몇 시간 안에 **핵심 개념**을 잡고, IoT/엣지(예: Zybo Z7-20)에서 **무엇을 선택/주의**해야 하는지 결정한다.

---

## 목차
- [1. 개요](#1-개요)
- [2. 보안의 4대 속성 (CIAA)](#2-보안의-4대-속성-ciaa)
- [3. 암호 프리미티브](#3-암호-프리미티브)
  - [3.1 대칭키 암호](#31-대칭키-암호)
  - [3.2 비대칭키(공개키) 암호](#32-비대칭키공개키-암호)
  - [3.3 해시 함수](#33-해시-함수)
  - [3.4 메시지 인증(HMAC)](#34-메시지-인증hmac)
  - [3.5 디지털 서명 & PKI(X509)](#35-디지털-서명--pkix509)
- [4. 블록암호 운용 모드(ECB/CBC/CTR/GCM)](#4-블록암호-운용-모드ecbccbctrgcm)
- [5. 스트림 암호 vs 블록 암호](#5-스트림-암호-vs-블록-암호)
- [6. 구조: Feistel vs SPN](#6-구조-feistel-vs-spn)
- [7. AEAD(Authenticated Encryption with Associated Data)](#7-aeadauthenticated-encryption-with-associated-data)
- [8. 경량암호(Lightweight Crypto) 개요](#8-경량암호lightweight-crypto-개요)
- [9. 알고리즘 카탈로그(ASCON/SIMON/SIMECK/PRESENT/국산)](#9-알고리즘-카탈로그asconsimonsimeckpresent국산)
- [10. PRESENT 한 장 요약(구조·이점·주의)](#10-present-한-장-요약구조이점주의)
- [11. HW 구현: 이득과 함정(SoC/FPGA)](#11-hw-구현-이득과-함정socfpga)
- [12. 구현 체크리스트](#12-구현-체크리스트)
- [13. 동형암호(HE) — 범위 밖 짧은 메모](#13-동형암호he--범위-밖-짧은-메모)
- [14. 참고/추가읽기](#14-참고추가읽기)

  # 1. 개요
암호화는 **평문(원본 데이터)**을 **암호문(읽을 수 없는 형태)**으로 바꾸어 **기밀성**을 보장하는 기술이다. 하지만 실제 시스템(특히 IoT/엣지)에서는 기밀성 하나로 끝나지 않는다. 데이터가 **변조되지 않았는지(무결성)**, 상대가 **진짜인지(인증)**, 그리고 나중에 “난 안 했다”라고 **부인하지 못하게(부인방지)** 하는 것까지 함께 설계해야 한다.   
현대 보안은 보통 다음 식으로 **조합**된다.

- **대칭키 암호**(빠르고 저전력)로 본 데이터 암호화
- **운용 모드**(CTR/GCM/…​)로 파일·스트림 처리
- **AEAD**(예: AES-GCM, ASCON-AEAD)로 **기밀성+무결성**을 한 번에
- **공개키 암호**(RSA/ECC)로 세션키 교환·전자서명(인증·부인방지)
- **해시/HMAC**으로 무결성 확인, **KDF**(Argon2 등)로 비밀번호 안전 저장

> **엣지/IoT 관점**: 연산·메모리·전력 제약이 크므로 **경량암호**(PRESENT, ASCON, SIMON/SIMECK 등)와 **키/IV 관리**를 우선순위로 잡는 것이 핵심이다.

---

# 2. 보안의 4대 속성 (CIAA)

## 2.1 기밀성 (Confidentiality)
**정의**: 인가되지 않은 자가 데이터를 **볼 수 없게** 하는 속성.  
**왜 중요?** 이미지·개인정보·기계상태 로그 등 유출 시 직접 피해와 신뢰 하락이 발생한다.  
**어떻게?** 신뢰할 수 있는 **대칭키 암호**(AES, PRESENT 등)로 암호화하고, 키는 **eFUSE/OTP/SE/PUF** 등 안전한 저장소에 둔다.  
**예시**: 암호화되지 않은 SD카드에 이미지가 평문으로 저장되면 카드를 분리해 곧장 열람 가능 → 기밀성 실패.  
**체크리스트**
- [ ] 강한 알고리즘/키 길이 선택 (임시 PoC라도 약식 알고리즘 금지)  
- [ ] **키 분리**(코드/펌웨어와 분리) 및 **키 교체 절차** 문서화  
- [ ] **IV/nonce 재사용 금지**(CTR/GCM, ASCON 등 스트림화·AEAD에서 치명적)

## 2.2 무결성 (Integrity)
**정의**: 전송/저장 중 **변조되지 않았음**을 보장.  
**왜 중요?** 암호화만 하고 무결성 검증이 없으면, 공격자가 암호문 한 블록을 바꾸어 **의미 있는 평문 변조**를 만들 수 있다(모드에 따라 다르지만 위험).  
**어떻게?** **AEAD**(AES-GCM, ASCON-AEAD 등)로 태그 검증을 포함하거나, 최소한 **HMAC**을 추가한다.  
**예시**: SD카드 암호문 일부가 손상되었는데 태그 검증이 없으면 복호화 결과가 틀려도 눈치 못 챈다.  
**체크리스트**
- [ ] 태그 검증 실패 시 **데이터 폐기**(경고만 띄우지 말 것)  
- [ ] 저장 매체/전송 경로의 **CRC**는 무결성 보조일 뿐, **보안 무결성**은 아님  
- [ ] 태그·메타데이터(AAD, 버전, nonce)는 **함께 저장**하고 재현 가능하게 기록

## 2.3 인증 (Authentication)
**정의**: 상대방/데이터의 **출처 확인**.  
**왜 중요?** 가짜 기기/공격자가 시스템에 접속해 데이터를 밀어 넣을 수 있다.  
**어떻게?** **전자서명**(ECDSA/EdDSA)이나 **챌린지-응답**(공유키)로 장치·서버 상호 인증. X.509 인증서를 쓰면 규모가 커져도 신뢰 체인이 유지된다.  
**예시**: 공격자가 가짜 카메라 모듈을 연결해 조작된 프레임을 주입 → 인증 미비 시 시스템이 그대로 저장.  
**체크리스트**
- [ ] 최초 등록(프로비저닝) 시 **장치별 키/인증서** 발급  
- [ ] 인증 실패/만료/취소(OCSP/CRL) 처리  
- [ ] 인증과 **권한(Authorization)**은 다르다—역할·정책 분리

## 2.4 부인방지 (Non-repudiation)
**정의**: 행위자가 나중에 “내가 안 했다”고 **부인하지 못하게** 하는 속성.  
**왜 중요?** 데이터 생성·전송에 대한 **책임 추적**과 법적 증거 능력에 직결.  
**어떻게?** 개인키로 **서명**하고 공개키로 **검증**(서명을 “복호화”한다고 표현하지 않음). 로그는 **서명/태그/타임스탬프**와 함께 보관.  
**체크리스트**
- [ ] 서명에 쓰는 개인키 보호(암호화 저장, 하드웨어 보호)  
- [ ] **시간 동기화**(신뢰 가능한 타임스탬프)와 로그 위변조 방지

---

# 3. 암호 프리미티브

## 3.1 대칭키 암호
**개념**: **같은 키**로 암·복호. 구조는 SPN(AES/PRESENT)이나 Feistel(SIMON/SIMECK) 등 다양하지만 공통 목표는 **혼돈(Confusion)**과 **확산(Diffusion)**을 충분히 주는 것.  
**장점**: 빠르고 저전력, 구현 단순. **대용량 데이터** 보호에 최적.  
**단점**: **키 배포**가 숙제(상대에게 안전하게 전달해야 함). 무결성은 별도(MAC/AEAD).  
**운용 모드**: 블록암호는 ECB/CBC/CTR/GCM 등 **모드**로 파일·스트림 처리. 실제로는 **CTR/GCM**이 주력(패딩 문제 적고 병렬화에 유리).  
**IoT/엣지 팁**
- **PRESENT**: 64b 블록/80·128b 키/31라운드. S-box(4b×16)+비트 전치. **소면적/저전력**, RTL로 쪼개기 좋음.  
- **AES**: 128b 블록/128·192·256b 키. HW 가속 있으면 **AES-GCM**이 표준급 선택.  
- **LEA/CHAM/HIGHT**: 임베디드 친화 알고리즘(국산 포함), 구현 자료 풍부.

**실수 방지**
- [ ] **약한 알고리즘/짧은 키** 금지(테스트라도 습관 들이지 말 것)  
- [ ] CTR/GCM 등에서 **IV/nonce 재사용 금지**—가장 흔한 치명적 실수  
- [ ] 키·IV 생성은 **좋은 RNG**(TRNG/DRBG) 사용

---

## 3.2 비대칭키(공개키) 암호
**개념**: **공개키/개인키** 한 쌍을 사용. 누구나 공개키로 암호화/검증, 개인키 소유자만 복호/서명.  
**역할**  
- **키 교환**: ECDH(또는 클래식 RSA 키 전송)로 세션키 합의  
- **전자서명**: ECDSA/EdDSA/RSA-PSS로 서명→검증(**부인방지**)  
**장점**: 키 배포가 쉬움(공개키 공개 가능), 인증·서명 기능 제공  
**단점**: 대칭키보다 **느리고 무거움** → 본 데이터 보호엔 부적합  
**현실 패턴**: TLS류처럼 **초기 핸드셰이크**에만 비대칭키를 쓰고, 합의된 **세션키**로 이후 **대칭키(AEAD)** 운용

**실수 방지**
- [ ] 개인키는 **절대 평문 저장 금지**(암호화·분리 저장, 가능하면 하드웨어 보호)  
- [ ] RSA는 **적절한 패딩(PSS/OAEP)**, ECC는 **곡선/키 길이** 최신 권장안 따를 것  
- [ ] 인증서(X.509) **유효기간/폐지**(CRL/OCSP)와 체인 검증 구현

---

## 3.3 해시 함수
**개념**: **임의 길이 입력 → 고정 길이 출력**으로 매핑하는 **단방향 함수**(복호화 개념 없음). 목적은 **무결성 검증**과 **지문 생성**이다.  
**핵심 성질**
- **역상 저항성(Preimage)**: 해시값만 보고 원본을 찾기 어려워야 함  
- **제2역상 저항성(Second-preimage)**: 같은 해시가 되도록 다른 입력을 찾기 어려워야 함  
- **충돌 저항성(Collision)**: 같은 해시를 내는 서로 다른 두 입력을 찾기 어려워야 함  
**주의(오해 정정)**: 해시는 “암호화”가 아니며, **복호화**라는 개념이 없다. 보안성은 **수학적 성질**과 **출력 길이**에 의존한다.

**공격 모델과 대응**
- **레인보우 테이블/사전공격**: 미리 계산된 매핑으로 원본 추정  
  → 입력에 **솔트(Salt)**를 섞어 테이블 무력화  
- **충돌 공격**: SHA-1/MD5는 충돌 생성이 실용 수준  
  → **SHA-256/512** 이상 사용 권장  
- **길이 확장 공격**: 단순 해시는 메시지 추가에 취약  
  → **HMAC** 사용 시 방어 가능

**패스워드 보관(별도 권고)**
- 단순 해시+솔트가 아니라 **KDF**(**Argon2 / scrypt / bcrypt / PBKDF2**) 사용  
- **워크 팩터**(메모리/반복 횟수)로 공격 비용 상향

---

## 3.4 메시지 인증(HMAC)
**개념**: **공유키**와 해시를 결합해 만든 **무결성+송신자 인증 코드**.  
**장점**: 구현 간단, 빠름, **길이 확장 공격에 안전**(HMAC 구조 덕분).  
**제한**: 송신자·수신자가 **같은 키**를 쓰므로 **부인방지 제공 X**(“누가 만들었는지” 제3자가 증명하기 어렵다).  
**사용 예**: HMAC-SHA256(가장 보편), IPsec, TLS 일부 모드 등  
**실수 방지**
- [ ] 키 길이는 충분히 길게(최소 128bit 이상 권장)  
- [ ] 메시지에 **메타데이터(AAD)**를 포함해 문맥 바인딩  
- [ ] 수신측은 **상수 시간 비교**로 태그 검증(타이밍 누설 방지)

---

## 3.5 디지털 서명 & PKI(X.509)
**디지털 서명**: 송신자가 **개인키로 메시지의 해시에 서명**, 누구나 **공개키로 검증** → **부인방지**와 **출처 인증** 제공.  
**대표 알고리즘**: ECDSA/EdDSA, RSA-PSS  
**PKI(X.509)**: 공개키를 **신뢰 가능하게 배포**하기 위한 인프라. **루트 CA → 중간 CA → 서버/클라이언트 인증서**의 체인, 만료/폐지(OCSP/CRL) 관리가 핵심.

**실무 흐름(예: 장치 등록)**
1) 장치에서 키쌍 생성(가능하면 하드웨어 내부)  
2) CSR 제출 → CA가 **장치 인증서** 발급  
3) 서비스 접속 시 **서버-장치 상호 인증**(서명 검증)  
4) 주기적 **갱신/폐지**로 신뢰도 유지

**실수 방지**
- [ ] 개인키는 **내보내지 않기**(가능하면 SE/TPM/TEE 내부 연산)  
- [ ] 체인 검증/신뢰 루트 관리, 만료·폐지 처리 필수  
- [ ] 서명은 “복호화”가 아니라 **검증**이라는 용어 사용

---

# 4. 블록암호 운용 모드 (ECB / CBC / CTR / GCM)

> **전제**: 블록암호(Block Cipher)는 고정 크기(예: 64/128비트)의 블록을 입력받아 같은 크기의 블록으로 바꾸는 함수다.  
> 파일·스트림처럼 **긴 데이터**를 처리하려면 **운용 모드(Mode of Operation)**가 필요하다.

**용어 미리 풀어쓰기**
- **IV(Initialization Vector)**: 첫 블록을 랜덤하게 섞기 위한 초기값(비밀은 아님).  
- **Nonce(Number used once)**: “한 번만 쓰는 숫자”. IV와 거의 비슷하지만 **절대 재사용하지 않는 유일값**을 더 강하게 의식.  
- **패딩(Padding)**: 블록 크기의 배수가 되도록 끝을 채우는 것.  
- **태그(Tag)**: 무결성을 검증하는 짧은 인증값(예: 16바이트).

---

### 4.1 ECB (Electronic Codebook)
**개념**: 각 블록을 **독립적으로** 암·복호.  
**장점**: 구현이 매우 단순, 패딩만 처리하면 됨.  
**치명적 단점**: 같은 평문 블록 → 같은 암호문 블록. **패턴이 그대로 노출**됨.  
**결론**: 실전 금지 수준(학습·디버깅 용도 외 X).


---

### 4.2 CBC (Cipher Block Chaining)
**개념**: `C_i = E(K, P_i ⊕ C_{i-1})`, 단 `C_0 = IV`. 이전 암호문과 **체인**을 이룸.  
**장점**: ECB 패턴 노출 해결. 구현 비교적 간단.  
**단점/주의**:  
- **직렬 처리**(병렬화 어려움) → HW 처리량 제한.  
- **패딩** 필요.  
- **무결성 없음**(암호화만). 별도 **HMAC**이나 **AEAD** 필요.  
**사용처**: 레거시 호환이 필요한 경우 정도.

---

### 4.3 CTR (Counter)
**개념**: 블록암호를 **키스트림 생성기**로 사용. `KS_i = E(K, Nonce || Ctr_i)`, `C_i = P_i ⊕ KS_i`.  
**장점**:  
- **병렬화** 매우 좋음(카운터만 다르게 넣으면 된다).  
- **패딩 불필요**(바이트 단위 처리).  
**단점/주의**:  
- **malleable(조작 가능)**: 무결성은 제공하지 않음 → **HMAC 또는 AEAD** 필요.  
- **(키, nonce) 재사용 금지**: 한 번이라도 재사용하면 원문이 드러남(XOR 성질).

**HW 팁**: IoT/FPGA에서 **간단하고 빠름**. PRESENT 같은 경량 블록암호에 잘 맞음.  

  
**카운터 증가 규칙(중요)**:
- 카운터는 일반적으로 **우측(하위 비트)부터 +1**(빅엔디언 카운터)로 증가시킨다.
- Nonce || Counter 합쳐 **64/96/128비트** 등 고정 길이를 사용하고, 오버플로 시 **세션 종료** 또는 **상위 필드(부팅 카운터 등) 증가**로 중복을 방지한다.
- 문서에 **엔디언/증가 규칙/오버플로 처리**를 명확히 적어 재현 가능하게 만든다.


---

### 4.4 GCM (Galois/Counter Mode) — **AEAD**
**개념**: CTR + **GHASH**(갈루아 필드에서의 다항식 해시)로 **태그** 생성 → **기밀성+무결성** 동시 제공.  
**장점**: 병렬화 우수, 널리 표준화되어 라이브러리/레퍼런스 풍부.  
**주의(매우 중요)**:  
- **96비트 Nonce 권장**.  
- **(키, nonce) 재사용 금지** — 재사용 시 **기밀성과 무결성 둘 다 붕괴**.  
- 태그 검증 실패 시 **데이터 폐기**(경고만 띄우지 말 것).
- **태그 길이**: 기본 128비트(16바이트) 권장. 구현 간소화/패킷 크기 절약 목적으로 96/112비트 등으로 줄일 수 있으나, 보안 여유가 감소하므로 제품에서는 가급적 128비트를 유지할 것.


---

### 4.5 실수 방지 체크리스트 (모드 공통)
- [ ] ECB 금지.  
- [ ] CTR/GCM 사용 시 **Nonce/IV 유일성** 보장(부팅횟수+카운터 조합 등 문서화).  
- [ ] 태그가 있는 모드(AEAD)는 **반드시 태그 검증** → 실패 시 폐기.  
- [ ] 저장 시 **메타데이터(AAD/버전/Nonce/길이)**를 함께 기록해 재현 가능하게.

---

# 5. 스트림 암호 vs 블록 암호

> **스트림 암호(Stream Cipher)**는 한 비트/바이트씩 흐르는 데이터에 **키스트림**을 XOR하는 방식.  
> **블록 암호(Block Cipher)**는 고정 크기 블록을 변환. 모드로 스트림처럼 동작시킬 수 있다(CTR 등).

**용어 미리 풀어쓰기**
- **키스트림(Keystream)**: 난수처럼 보이는 비트열. 평문과 XOR해서 암·복호에 사용.  
- **생일한계(Birthday Bound)**: 블록 길이가 n비트일 때 약 **2^(n/2)** 블록 근처에서 충돌 가능성이 의미 있게 커지는 경계.

---

### 5.1 스트림 암호
**장점**:  
- 지연 낮고, 패딩 필요 없음.  
- 바이트/비트 단위 처리에 유리(실시간 스트리밍).  
**주의**:  
- **같은 (키, nonce)** 재사용 → 두 암호문 XOR하면 **평문 XOR**가 바로 나옴(원문 누설).  
- 무결성 제공 X → **HMAC/AEAD** 필요.  
**예시**: **ChaCha20**, (사실상 CTR 운용의 블록암호도 **스트림처럼 동작**).

---

### 5.2 블록 암호
**장점**:  
- 오랜 분석과 표준화(신뢰도).  
- HW 구현 쉬움(S-box/배선 최적화), **파이프라인** 설계 가능.  
**주의**:  
- **블록 크기 생일한계**: 64비트 블록(PRESENT 등)은 *아주 큰 대용량*에서는 한계에 빨리 다가감 → **Nonce/카운터 관리**를 더 엄격히.  
- 모드 선택에 실패(ECB/잘못된 IV 등)하면 보안 붕괴.

**생일한계 예시**: 64비트 블록은 대략 **2^(64/2)=2^32 ≈ 43억 블록**(≈ 34GB, 8B 블록 가정) 규모에서 충돌 확률이 통계적으로 의미 있게 커진다. 장시간 스트리밍/대용량 저장이면 **Nonce/카운터 유일성**을 더 엄격히 관리하거나 128비트 블록(AES)·AEAD를 우선 고려하자.

---

### 5.3 선택 가이드 (엣지/FPGA)
- **기능검증(암복호만)**: **CTR**(간단·패딩X·병렬화)  
- **제품화(무결성 포함)**: **AEAD** 계열(ASCON-AEAD / AES-GCM)  
- **대용량·장시간**: 64b 블록(PRESENT)은 **nonce/카운터** 더 엄격히, 가능하면 128b 블록(AES)·AEAD 고려

---

# 6. 구조: Feistel vs SPN (Substitution–Permutation Network)

**공통 목표**:  
- **혼돈(Confusion)**: 키와 출력의 관계를 **복잡하게 꼬이게**(S-box 같은 비선형 연산)  
- **확산(Diffusion)**: 한 비트 변화가 전체로 퍼지게(비트 전치, 선형 변환)

**용어 미리 풀어쓰기**
- **S-box(Substitution box)**: 작은 룩업 테이블 형태의 **비선형 치환**.  
- **Permutation(전치/확산층)**: 비트/바이트 위치를 **섞어 퍼뜨리는 선형 연산**.

---

### 6.1 Feistel 구조
**형태**: 입력을 좌/우(L/R)로 나눠 **반쪽만** 함수 F로 변환 후 XOR.  
`L_{i+1} = R_i`  
`R_{i+1} = L_i ⊕ F(R_i, K_i)`  
**복호화**: 같은 F를 쓰되 **키 순서를 역순**으로 적용 → **복호 함수 별도 설계 불필요**.  
**대표**: **DES**, **SIMON**, **SIMECK**(ARX: Add/Rotate/XOR 성분 중심).  
**HW 관점**: F를 얼마나 단순/빠르게 만드느냐가 관건. **복호가 쉬운 점**이 장점.

---

### 6.2 SPN 구조
**형태**: **S-box(비선형)** → **P-레이어(확산)**를 여러 라운드 반복.  
복호 시에는 **역 S-box**, **역 확산**이 필요.  
**대표**: **AES**, **PRESENT**, **PIPO**.  
**HW 관점**:  
- 여러 S-box를 **병렬 배치** 가능 → **처리량↑**  
- 완전 직렬화도 가능 → **면적↓**  
- 고정 배선의 P-레이어는 FPGA에서 배선 최적화로 **전력↓/지연↓** 기대.

---

### 6.3 비교 요약

| 항목 | Feistel | SPN |
|---|---|---|
| 복호 구현 | **쉬움**(키 역순) | **역 S-box/역 확산 필요** |
| HW 병렬화 | F 구조에 좌우됨 | **S-box 병렬화 용이** |
| 예시 | SIMON/SIMECK | AES/PRESENT |
| 설계 포인트 | F의 설계 품질 | S-box 품질·확산 강도 |

---

# 7. AEAD (Authenticated Encryption with Associated Data)

> **AEAD**는 **기밀성(암호화)**과 **무결성/인증(태그)**을 **한 번에** 제공하는 암호화 방식이다.

**용어 미리 풀어쓰기**
- **AAD(Associated Data)**: 암호화하지는 않지만 **태그 계산에 포함**되는 메타데이터(예: 헤더/버전/파일명).  
- **태그(Tag)**: 수신자가 검증하는 **무결성 증명값**(검증 실패 시 데이터 폐기).

---

### 7.1 왜 AEAD인가?
- 암호화만 있으면 **조작(변조)**을 못 막음 → 무결성/인증이 필요.  
- HMAC을 별도로 붙일 수도 있지만, AEAD는 설계/검증을 통합해 **실수 가능성↓**.

---

### 7.2 대표 AEAD
- **AES-GCM**: CTR + GHASH(갈루아 필드 해시)로 태그 생성. **HW 가속** 있으면 빠르고 표준적.  
- **ASCON-AEAD**: 순열·스펀지 기반의 **경량 AEAD**. 코드/메모리 발자국이 작아 **저자원 장치**에 유리.

---

### 7.3 사용 규칙 (중요)
- **(키, Nonce) 재사용 금지**: 같은 키로 같은 Nonce를 반복 사용하면 **기밀성과 무결성 모두 붕괴**.  
- **Nonce 길이/형식**: GCM은 **96비트** 권장(단순·안전). Nonce는 보통 **카운터+디바이스ID+랜덤** 조합으로 유일성 확보.  
- **태그 검증 실패 처리**: **즉시 폐기**(부분적으로라도 사용 금지).  
- **AAD 기록**: 버전/헤더/메타를 AAD에 넣고, **같이 저장**해 재현 가능하게.

---

### 7.4 저장 포맷 예시(이미지 → SD)
```text
[Header/AAD]
  version:    u16
  algo:       enum { PRESENT-CTR, AES-GCM, ASCON-AEAD, ... }
  nonce:      12 or 16 bytes (정책 문서화)
  frame_no:   u32 (또는 timestamp)
  length:     u32 (ciphertext 길이)
[Ciphertext ...]
[Tag]         16 bytes (AES-GCM/ASCON-AEAD 기준)
```

- **복호 과정**: 키/Nonce/AAD로 태그 먼저 검증 → 성공 시 복호.  
- **장점**: 파일이 손상되거나 조작되면 **복호 전**에 감지 가능.

---

### 7.5 프로젝트 적용 가이드
- **기능검증 단계**: 구현이 단순한 **CTR**부터(패딩X, 병렬화↑) → IV/Nonce 재사용 금지 문서화.  
- **제품화 단계**: **AEAD**로 전환(**ASCON-AEAD** 또는 **AES-GCM**)하고,  
  - **Nonce 생성기**(카운터+랜덤),  
  - **태그 실패 처리 경로**,  
  - **메타데이터(AAD) 포맷**을 고정.  
- **HW 최적화**: 파이프라인/직렬화 선택, RNG(TRNG/DRBG) 품질 확보, **부채널 최소 위생**(상수시간/접근패턴 고정).

---

### 7.6 빠른 체크리스트
- [ ] AEAD 또는 CTR+HMAC 중 **하나**를 택해 **무결성** 보장  
- [ ] **Nonce 정책**: 유일성 보장/재부팅 시 중복 방지/로그 기록  
- [ ] **태그 실패 시 폐기** 로직 구현(에러 코드·로그 포함)  
- [ ] **AAD 설계**: 버전/알고리즘/Nonce/길이/파일명 등 문맥 고정  
- [ ] 테스트: **공개 테스트벡터** + **파일 왕복(round-trip)** + **에러 주입**(태그/Nonce 변경)

---

# 8. 경량암호(Lightweight Crypto) 개요

> **경량암호**는 **자원 제약(면적/전력/메모리/지연)**이 큰 IoT/엣지·임베디드 기기를 위해 설계된 암호다.  
> 목표는 “**충분한 안전성**을 유지하면서 **작게·싸게·오래가게**” 만드는 것.

**용어 미리 풀어쓰기**
- **면적(Area)**: ASIC의 게이트 등가 수/FPGA의 LUT·FF 수(= 칩 크기·단가와 직결).
- **전력(Power)**: 동작 시 소비전력(배터리 수명·발열과 직결).
- **지연/처리량(Latency/Throughput)**: 한 블록을 처리하는 데 걸리는 사이클/초당 처리 비트 수.
- **직렬화(Serialization)**: 하드웨어 연산 유닛을 작게 만들고 **여러 번 돌려 쓰는** 방식(면적↓, 지연↑).
- **파이프라인(Pipeline)**: 연산 단계를 분할해 **동시에 흘리는** 방식(처리량↑, 면적↑).

### 8.1 설계 트레이드오프
- **S-box 작게** + **단순 확산층(전치/회전)** → 하드웨어 면적·전력 절감  
- **직렬화**로 극소면적 구현(예: 4비트 S-box 1개만 돌려 쓰기) vs **병렬화**로 고처리량(16개 병렬)
- **64비트 블록** 채택(소형화 유리) ↔ **생일한계**가 빨리 온다(대용량/장시간 처리 시 IV/nonce 관리가 더 엄격)

### 8.2 운용상 원칙(엣지/FPGA 관점)
- 기능검증(암복호만) 단계: **CTR** 모드가 단순·패딩無·병렬화 OK  
- 제품화(무결성 포함) 단계: **AEAD**(예: **ASCON-AEAD**, **AES-GCM**) 사용  
- **키·IV/nonce 관리**를 설계 초기에 문서화(유일성, 생성 규칙, 저장 위치, 수명주기)
- **부채널(전력/EM/타이밍/글리치) 최소 위생**: 상수시간화, 접근 패턴 고정, (제품) 1차 마스킹

---

# 9. 알고리즘 카탈로그 (ASCON / SIMON / SIMECK / PRESENT / 국산)

> 각 알고리즘의 **핵심 개념·장단점·추천 사용처**를 한눈에.

**공통 용어**
- **SPN(Substitution–Permutation Network)**: S-box(비선형 치환) → P-레이어(선형 확산) 반복 구조.
- **Feistel**: 입력을 L/R로 나누고 반쪽만 F함수로 변환 후 XOR하는 구조(복호가 쉬움).
- **ARX(Add–Rotate–XOR)**: 덧셈·회전·XOR만으로 구성된 경량 연산 스타일(하드웨어 친화).

---

### 9.1 ASCON (경량 **AEAD/해시**)
- **종류/역할**: 블록암호가 아니라 **순열(퍼뮤테이션) 기반 스펀지 구조**의 **AEAD/Hash**.  
  *(스펀지: 내부 상태를 흡수(absorb)·짜내기(squeeze)로 운용하는 프레임워크)*
- **장점**: 코드/메모리 발자국 작음, **AEAD 태그**로 무결성까지 동시 제공, 저자원 장치 적합
- **주의**: Nonce 재사용 금지, 공개 테스트 벡터로 반드시 교차검증
- **추천**: **AEAD가 필요한** 센서/엣지 로그 저장·전송, 마이크로컨트롤러

---

### 9.2 SIMON / SIMECK (경량 **블록암호**, Feistel/ARX)
- **구조**: Feistel + **회전/AND/XOR(ARX)** 중심 → LUT 적고 빠름
- **장점**: **하드웨어 구현 용이**, 면적/전력 효율 우수, 다양한 블록·키 조합
- **주의**: 변종이 많아 **정확한 파라미터**를 명기해야 함(테스트 벡터와 세트로)
- **추천**: 초소형 하드웨어(저가 FPGA/ASIC), 직렬화 구현

---

### 9.3 PRESENT (경량 **블록암호**, **SPN**)
- **구조**: 4비트 **S-box ×16 병렬** + **비트 단위 전치(P-레이어)**, **31라운드**
- **장점**: **소면적/저전력**, 구조 단순 → RTL로 깨끗하게 분할 가능(코어/키스케줄/제어)
- **주의**: **64비트 블록** → 대용량 처리 시 **생일한계** 및 IV/nonce/카운터 관리 엄격
- **추천**: 면적이 극도로 제한된 FPGA/ASIC, 교육/연구·제품 PoC

---

### 9.4 국산 계열(LEA / CHAM / HIGHT / PIPO 등)
- **LEA/CHAM**: 128비트 블록/ARX 계열(변형에 따라 다름). 소프트/하드 모두 구현 예시 풍부  
- **HIGHT**: 경량 블록암호(64b 블록). 임베디드에서 소면적 구현 사례 다수  
- **PIPO**: 소형 S-box 기반 경량 SPN(연구·교육 자료 다양)
- **추천**: 국내 문서/레퍼런스 접근성, 하드웨어 실습 자료 확보에 유리

---

### 9.5 빠른 선택 가이드
- **무결성 포함(AEAD 필요)**: **ASCON-AEAD**(저자원) / **AES-GCM**(HW 가속 시 최우선)
- **암복호만(기능검증/초소형)**: **PRESENT-CTR** or **SIMON/SIMECK-CTR**
- **장시간·대용량**: 128b 블록 계열(AES/LEA) 또는 **AEAD** 우선

---

# 10. PRESENT 한 장 요약 (구조·이점·주의)

**용어 다시 보기**
- **S-box(4비트)**: 0~15(4b) 입력 → 0~15 출력의 **비선형 치환 테이블**.  
- **P-레이어(Permutation layer)**: 64비트 상태의 **비트 위치를 재배열**해 확산을 주는 고정 배선.  
- **화이트닝(AddRoundKey)**: 라운드마다(및 최종) **라운드키를 XOR**해 키 종속성을 부여.

---

### 10.1 파라미터 & 라운드 구조
- **블록/키**: 64비트 블록, **80/128비트 키**, **31 라운드**
- **라운드 순서**(암호화)
  1) **AddRoundKey**: 상태(64b) ⊕ 라운드키(64b)  
  2) **S-box 층**: 4비트 S-box를 **16개 병렬** 적용(64b → 64b)  
  3) **P-레이어**: 비트 위치 고정 전치(확산)
- **복호화**: 역 S-box/역 P-레이어 + **라운드키를 역순 적용**

> 구현 팁: S-box를 **1개만** 두고 16번 돌리면 **초소면적**, 16개 병렬 두면 **고처리량**.  
> P-레이어는 단순 배선(셔플)이므로 **조합회로**로 두고 타이밍만 맞추면 됨.

---

### 10.2 키 스케줄(요지)
- **PRESENT-80**: 80b 키 레지스터를 **좌회전(rol) 61비트** → 상위 4비트에 **S-box 적용** → 라운드 카운터를 특정 비트에 XOR → 다음 라운드키 생성  
- **PRESENT-128**: 128b 키 레지스터에서 **상위 바이트들에 S-box 적용** + 라운드 카운터 XOR(세부 비트 위치는 구현문서 참고)
- **검증 포인트**: **라운드 카운터**가 제대로 XOR됐는지, 회전 비트폭/방향 착오가 없는지, S-box 입력 비트 정렬

---

### 10.3 아키텍처 선택(면적↔처리량)
| 아키텍처 | 설명 | 장점 | 단점 | 쓰임새 |
|---|---|---|---|---|
| **완전 직렬(초소면적)** | S-box 1개, 1라운드에 16번 사용 | 면적·전력 최소 | 지연↑, 처리량 낮음 | 초소형 ASIC/FPGA |
| **라운드 단위 반복(표준)** | S-box 16개, 라운드별 1사이클 또는 수사이클 | 균형형 | 중간 면적 | 일반적 PoC/제품 |
| **완전 파이프라인(고속)** | 라운드별 파이프라인, 31스테이지 | 처리량 최고 | 면적↑↑, 레이턴시↑ | 고속 데이터 경로 |

**처리량 근사**:  
`Throughput ≈ (BlockSize / CyclesPerBlock) × f_clk`  
예) 64b, 31사이클/블록, 100MHz → 약 206 Mbit/s

---

### 10.4 모드/시스템 통합
- **CTR 래퍼**(권장): `KS = E_K(Nonce||Ctr)` 생성 → `C = P ⊕ KS`  
  - **Nonce/카운터 관리** 문서화(부팅횟수·프레임번호·랜덤 조합)  
  - 복호화도 동일 경로(CTR 특성)
- **AEAD 전환**: 무결성까지 필요하면 **ASCON-AEAD** 또는 **AES-GCM**로 상위 레벨에서 래핑
- **메타데이터(AAD)**: 버전/알고리즘/Nonce/길이/파일명 등을 태그와 함께 저장

---

### 10.5 부채널·신뢰성 포인트
- **상수시간화**: 조건분기 제거, 시프트/배선 경로 고정  
- **메모리 패턴 고정**: S-box 테이블 접근 패턴 일정(가급적 조합논리화)  
- **(제품) 1차 마스킹**: S-box 입력/출력 마스킹(랜덤 값과 XOR)  
- **Fault 대비**: 중요 구간 이중 계산/체크태그(결함 주입 대응)  
- **테스트**: 공개 **테스트 벡터**로 블록 검증 → CTR 스트림 검증 → **파일 왕복(round-trip)** + **에러 주입(Nonce/태그 변조)**

---

### 10.6 구현 체크리스트(요약)
- [ ] S-box 매핑/비트 정렬/엔디안 일관성 확인  
- [ ] 키 스케줄: **rol 61**(PRESENT-80)·S-box 적용·라운드 상수 XOR 정확성  
- [ ] 라운드 수 **31** 고정, **최종 AddRoundKey** 누락 금지  
- [ ] CTR: **(키, Nonce) 유일성** 보장, 카운터 오버플로 처리  
- [ ] 타이밍/합성: P-레이어 배선 타이밍 경로 점검, 파이프라인 단계 조정  
- [ ] 부채널 위생: 상수시간·접근패턴 고정 → (제품) 마스킹/TVLA  
- [ ] 검증: 벡터·스트림·파일·에러주입 테스트 세트 확보

---

# 11. HW 구현: 이득과 함정(SoC/FPGA)

> **왜 하드웨어(HW)로?** — **고처리량·저지연·저전력**이 가능하고, 펌웨어처럼 코드가 그대로 노출되지 않는다.  
> **왜 어렵나?** — **부채널(전력/EM/타이밍/결함)**, **키 보관**, **업데이트/수명주기**가 생각보다 까다롭다.

**용어 미리 풀어쓰기**
- **부채널(Side Channel)**: 수학이 아닌 **전력 소모·시간 지연·전자파(EM)** 같은 물리 신호로 정보가 새는 현상.  
- **TVLA(Test Vector Leakage Assessment)**: 전력/EM 누설을 **통계적으로 검정**해 누설 여부를 판단하는 시험(일종의 t-test).  
- **TRNG/DRBG**: **진난수(TRNG)** 또는 **의사난수 생성기(DRBG)**. IV/nonce·마스킹·챌린지값에 필요.  
- **eFUSE/OTP/SE/TPM/PUF**: (키 저장/보호) **eFUSE/OTP**=영구 소각형, **SE/TPM**=보안칩, **PUF**=칩 고유 물리특성으로 키 **생성**.

### 11.1 이득(Pros)
- **처리량/지연 최적화**: 라운드 파이프라인·병렬 S-box 등으로 **Gbps급**도 가능.
- **전력 효율**: 동일 성능 기준 SW 대비 에너지/초 절감.
- **공격면 축소**: 바이너리/라이브러리 노출보다 역공학 난이도 상승(단, 물리측정 공격은 별개).

### 11.2 함정(Cons)
- **부채널 취약**: (예) S-box 접근 패턴/연산 시점 차이가 키와 상관관계를 가짐.  
  → **상수시간화**, **접근 패턴 고정**, (제품 단계) **마스킹/노이즈/차폐** 필요.
- **키 수명주기**: 공장 **프로비저닝**→ 배포 → **로테이션/폐기**까지 전 과정 정의 필요.
- **업데이트 비용**: FPGA는 bitstream 배포·검증(서명/해시)·롤백 정책 까지 고려.
- **타이밍/합성 이슈**: P-레이어 배선 딜레이, S-box 경로 폭주, 클럭 도메인 교차(CDC) 등.

### 11.3 아키텍처 선택(요약)
| 유형 | 설명 | 장점 | 단점 | 추천 상황 |
|---|---|---|---|---|
| **직렬형** | S-box 1개 반복 | 면적↓ 전력↓ | 지연↑ 처리량↓ | 초소형 FPGA/ASIC |
| **라운드 반복형** | 라운드당 S-box 16개 | 균형형 | 면적 중간 | 일반 PoC/제품 |
| **완전 파이프라인** | 31단(예: PRESENT) | 처리량↑↑ | 면적↑↑, 지연↑ | 고속 데이터 경로 |

### 11.4 보안 부트(Secure/Measured Boot) 짧은 메모
- **Secure Boot**: 부팅 이미지(bootloader/bitstream)가 **서명 검증** 통과해야 실행.
- **Measured Boot**: 해시를 **기록**해 사후 검증(무결성 **감사 추적**).
- FPGA/PSoC 보드에서는 **부트 체인**(ROM → FSBL → bitstream → OS)의 각 단계에 **해시/서명** 적용 권장.

---

# 12. 구현 체크리스트(End-to-End)

> 단계별로 **실패 가능 포인트**를 없애는 체크리스트. “기능검증(CTR) → 제품화(AEAD)” 로드맵을 가정.

### 12.1 기획/설계 전(Threat Model + 요구사항)
- [ ] **자산 정의**: 보호할 것(이미지/키/로그), 공격자 모델(물리 접근? 원격?)  
- [ ] **목표 결정**: 기능검증(암복호만) vs 제품화(AEAD 포함)  
- [ ] **알고리즘/모드 선택**: PRESENT-CTR(기능검증) / **ASCON-AEAD** or **AES-GCM**(제품화)  
- [ ] **키 길이/블록 크기**: 64b 블록(생일한계) 주의/IV 정책 강화 문서화  
- [ ] **성능 지표**: 처리량(↑↓), 지연, LUT/FF, 전력 예산

### 12.2 RTL 설계
- [ ] **모듈 분해**: `core(라운드)` / `key_schedule` / `round_ctrl` / `ctr_wrapper`  
- [ ] **S-box 구현**: 조합 논리(케이스/룩업)로 **상수시간**(테이블 캐시 접근 금지)  
- [ ] **P-레이어**: 고정 배선으로 구성, 타이밍 경로 확인  
- [ ] **키 스케줄**: PRESENT-80 **rol 61** + 상수 XOR + S-box 적용(비트 정렬 재확인)  
- [ ] **상수시간화**: 조건 분기/메모리 패턴 변화를 키와 무관하게  
- [ ] **RNG 인터페이스**: TRNG/DRBG에서 **nonce/카운터 씨드** 공급

### 12.3 시뮬레이션/검증
- [ ] **공개 테스트벡터**로 블록단위 일치 확인(라운드별 내부 상태까지 스팟 체크)  
- [ ] **CTR 스트림**: 고정 키/nonce로 N개 블록 비교(레퍼런스 스크립트와 바이트 정확 매칭)  
- [ ] **파일 왕복(Round-trip)**: 평문→암호문→복호문 완전 동일  
- [ ] **에러 주입**: Nonce 1비트 변경 / 카운터 역전 / (AEAD 단계) 태그 1비트 변경 → 실패 처리 확인  
- [ ] **카버리지**: 키스케줄 경계(라운드 상수)·카운터 오버플로·리셋 경로 포함

### 12.4 합성/FPGA 적용
- [ ] **타이밍 여유**: Fmax, 멀티사이클(있다면) 선언, CDC 처리  
- [ ] **리소스**: LUT/FF/BRAM 사용량 예산 내인지 확인  
- [ ] **전력**: 활동성 추정, 토글률 낮추기(클럭 게이팅/Enable)  
- [ ] **I/O**: 카메라/SD/AXI-Stream 등 인터페이스 타이밍 제약(XDC) 설정

### 12.5 펌웨어/드라이버 연동
- [ ] **레지스터 맵**: `KEY`, `NONCE`, `CTR`, `CFG`, `STATUS`, `ERR` 등 정의  
- [ ] **Nonce 정책**: 부팅 카운터+랜덤을 합성, **로그로 영구 기록**(중복 방지)  
- [ ] **에러 경로**: 태그 실패/Nonce 재사용 감지 시 **즉시 폐기 + 이벤트 로그**  
- [ ] **메타(AAD) 포맷**: 버전/알고리즘/Nonce/길이/파일ID — **고정 구조체**로 기록

### 12.6 제품화 보안(선택)
- [ ] **키 주입**: 공장 프로비저닝 절차(시리얼/설비/로그)  
- [ ] **키 저장**: eFUSE/OTP 또는 SE/TPM/PUF 정책 선택(교체/폐기 절차 포함)  
- [ ] **Secure Boot**: bitstream/펌웨어 서명 및 검증  
- [ ] **부채널 평가**: 최소 TVLA(전력/EM), (가능하면) 1차 마스킹 적용  
- [ ] **취약점 관리**: 알고리즘/라이브러리 버전 추적, 갱신/롤백 경로

---

# 13. 동형암호(HE) — 범위 밖이지만 개념만

> **목표**: 서버가 **데이터를 직접 보지 않고**(기밀성 유지) 연산/통계를 수행하게 하는 기술.

**용어 미리 풀어쓰기**
- **PHE(Partial HE)**: 한 가지 연산만 보존(예: **RSA**=곱셈, **Paillier**=덧셈).  
- **FHE(Full HE)**: 이론상 **임의의 회로**를 암호문 상태에서 평가.  
- **노이즈/부트스트랩**: 계산을 할수록 암호문에 **노이즈**가 쌓여 복호 불능이 되기 때문에, 이를 **줄여주는 과정**이 필요(매우 무거움).  
- **CKKS**: **근사 연산**(부동소수점 비슷)을 위해 설계된 FHE 방식.

### 13.1 장단점
- **장점**: 데이터 노출 없이 분석/ML 추론 가능 → 프라이버시 최고 수준  
- **단점**: **매우 느림/메모리 큼/암호문 팽창**(평문 대비 10×~100× 이상도 흔함). 엣지/FPGA에선 실시간 처리 **부적합**.

### 13.2 언제 쓰나?
- 의료/금융 **클라우드 분석**처럼, 데이터 유출 리스크가 절대적으로 커서 성능을 희생해도 되는 경우.  
- **본 프로젝트(카메라→FPGA→SD 암호화)**에는 **과도한 선택**. AEAD 또는 CTR+HMAC이 현실적.

---

# 14. 참고/추가읽기(한글 위주 + 표준 문서)

> 아래 자료는 “개념 빨리 잡기 → 구현/검증에 바로 쓰기” 기준으로 추렸다.

- **KISA 암호 키 관리 안내서** — 키 생성/보관/배포/폐기까지 수명주기 가이드.  
- **KISA 부채널 공격 취약성 평가** — 전력/EM/타이밍/결함 주입과 TVLA 개요·평가 절차.  
- **PRESENT 구조/키스케줄/테스트 벡터** — 한글 논문/특허 요약 및 구현 보고서 다수(라운드 순서·rol 61 등 확인).  
- **SIMON/SIMECK 개요** — Feistel/ARX 계열 경량 블록암호 구현 참고(파라미터 세트 주의).  
- **NIST 경량암호 표준(ASCON)** — AEAD/Hash/XOF 권장 파라미터·테스트벡터.  
- **AES-GCM 권고** — 96비트 Nonce 권장, 태그 검증 실패 처리.  
- **패스워드 KDF** — Argon2/scrypt/bcrypt 권고 파라미터 개요.  
- **Secure/Measured Boot** — 부트 체인 서명/해시, 롤백 방지 개념 정리.

> 구현 단계에서 막히면:  
> ① **테스트 벡터**로 블록·스트림부터 일치 → ② **파일 왕복** → ③ **에러 주입**(Nonce/태그 변경) → ④ **타이밍/전력** 확인 순으로 좁혀가면 **디버깅 시간이 절반**으로 줄어든다.






<!--
#  암호학 기본 개념 정리 (IoT/엣지 초급용) + 경량암호 & PRESENT 한눈에 보기
## 암호화란?
-암호화란 정보를 보호하기 위해 평문(원본 데이터)을 특정 알고리즘을 통해 암호문(이해할 수 없는 형태)으로 변환하는 과정이다.  
암호에 대해서 가장 중요한 것은 기밀성을 제공하는 것이다.  
현대 사용하는 암호화 방식에는 대칭 암호화, 비대칭 암호화, 해쉬 크게 3가지가 있다.  

<br>

## 보안의 4대 속성(CIAA) , 무결성 (Integrity), 인증 (Authentication), 부인방지 (Non-repudiation)  
### 기밀성 (Confidentiality)**  
정의: 인가되지 않은 사용자가 정보를 열람할 수 없게 하는 것.  

목적: 정보의 노출 방지.  

수단: 암호화, 접근 제어, 키 관리.   

예시: 암호화되지 않은 저장소에 키파일을 두면 기밀성 위반.  

하드웨어 예시: FPGA 내부에 고정된 비밀키(eFUSE, OTP)에 저장 → 외부에서 읽기 불가.  
<br>
### 무결성 (Integrity)
정의: 데이터가 전송되거나 저장되는 동안 변조되지 않았음을 보장하는 것.  

목적: 데이터의 정확성과 신뢰성 유지.  

수단: 해시(Hash), MAC, 디지털 서명, CRC.  

예시: SD카드에 저장된 암호문이 일부 손상됐는데, 검증 단계가 없으면 잘못된 복호화 결과가 나옴.  

하드웨어 예시: 복호화 직전 해시값 비교 블록 삽입 → 변조 여부 확인.  
<br>
### 인증 (Authentication)  
정의: 통신 상대방이나 데이터의 출처를 확인하는 과정.  

목적: “누가 보냈는가” “진짜 장치인가”를 검증.  

수단: 패스워드, 디지털 서명, 인증서, 챌린지-응답 프로토콜.  

예시: 공격자가 가짜 센서나 외부 장치를 연결해 데이터를 보내도 시스템이 속지 않게 함.  

하드웨어 예시: FPGA–MCU 간 통신 시 디지털 서명 기반 인증 절차 추가.  
<br>
### 부인방지 (Non-repudiation)
정의: 통신이나 행위를 수행한 당사자가 나중에 부인하지 못하도록 하는 것.  

목적: 책임 추적성 확보(“누가, 언제, 무엇을 했는가”).  

수단: 전자서명, 로그 무결성, 타임스탬프.  

예시: 사용자가 이미지 전송 후 “난 안 보냈다”고 주장해도 서명으로 증명 가능.  

하드웨어 예시: 보안 로그를 서명과 함께 저장하거나, TPM·Secure Element에 저장.    

---
## 대칭키 암호화

대칭키 암호화는 **암호화와 복호화에 동일한 키를 사용**하는 방식으로, 일반적인 자물쇠와 열쇠의 관계와 유사하다. 하나의 열쇠로 자물쇠를 잠그고 같은 열쇠로 여는 것처럼, 하나의 비밀키로 데이터를 암호화하고 같은 키로 복호화한다. 비대칭키 암호화에 비해 알고리즘이 단순하여 CPU 리소스 소모가 적고 처리 속도가 빠른 장점이 있다. 대표적인 알고리즘에는 **DES, AES, SEED, ARIA** 등의 있다.  
암호화 실습(AES)
 
아래 사이트는 다양한 암호 기법을 실습해 볼 수 있는 사이트이다.  
https://emn178.github.io/online-tools/aes/decrypt/  
<br>

## 비대칭키(공개) 암호화
대칭키 암호화는 **암호화와 복호화에 서로 다른 키를 사용**하는 방식이다. 키페어(한 쌍) 즉, 하나의 키로 암호화하면 다른 하나의 키로 복호화할 수 있는 특징이 있다. 송신자는 수신자의 공개된 **공개키를 가지고 암호화**하여 데이터를 보내면, **개인키를 가지고 있는 수신자만이 복호화**할 수 있다. 대표적인 알고리즘으로는 **RSA 방식**이 존재한다.  
 
왜 이렇게 복잡하게 암호화를 해야 할까? 그 이유는 바로 대칭키 방식의 한계를 극복하기 위함이다. 대칭키 방식은 암복호화 시, 동일한 키를 사용하기 때문에, 키를 교환하는 과정에서 원하지 않는 사람에게 키가 노출될 수 있다.(키노출사고)  
 
하지만, 그렇다고 해서 비대칭키 암호화가 장점만 존재하는 것은 아니다. 보안성이 뛰어난 만큼, 복잡한 로직(수학적 연산)으로 인해 대칭키 암호화보다 리소스 소모가 훨씬 크다. 그래서 실제 통신 환경에서는 두 방식을 효율적으로 조합하여 사용한다. SSL/TLS와 같은 보안 프로토콜에서의 경우 초기 연결 설정(핸드세이크) 단계에서만 비대칭키 암호화를 사용하여 안전하게 PMS(Pre-Master Secret)라는 임시 대칭키를 교환하고, 이후 실제 데이터 통신은 이 PMS를 기반으로 생성된 세션 키(대칭키)를 사용하여 암호화한다.  

<br>

## HASH 함수  
해시 함수는 **임의 길이의 데이터를 고정된 길이의 값으로 변환하는 단방향 암호화 기술**이다. 단방향이라는 것은 원본 데이터를 **암호화할 수는 있지만, 복호화할 수는 없다**는 의미이다. 이러한 단방향 암호의 주요 목적은 정보 은닉이 아닌, **데이터 무결성을 검증**하기 위함이다.
 
해시 함수는 **원본데이터를 조금이라도 변경하면, 출력되는 암호화 값이 아예 달라지므로**, 원본 데이터를 추측할 수 없게 한다. 해시 함수는 데이터 무결성 검증에 이상적이지만, 치명적인 보안적 취약점도 존재한다.
 
해시 함수의 특성상 동일한 입력에는 항상 동일한 출력값이 생성되므로, 공격자가 미리 계산된 해시값 목록(레인보우 테이블)을 구축하여 역으로 원본 데이터를 찾아낼 수 있다. 이러한 취약점을 해결하기 위해 대표적으로는 솔트(Salt) 기법이 적용된다. 솔트는 해시하기 전 원본 데이터에 임의의 값을 추가하여 동일한 입력이라도 다른 해시값이 생성되게 한다.
 
이러한 무차별 대입공격과 레인보우 테이블 공격에 대응하기 위해서는 보다 강력한 해시 알고리즘을 사용하는 것이 중요하다. 실제로 대부분 보안 표준 기관들은 MD5, SHA-1과 같은 취약한 알고리즘 대신, SHA-256, SHA-512 같은 강력한 해시 알고리즘을 사용하도록 권고한다.

<br>

## 메시지 인증 : 메시지의 무결성  
메시지 인증은 데이터 전송 과정에서 **원본 데이터의 무결성을 보장**하기 위한 기술이다.  보낸 사용자의 원본 데이터가 변경되지 않았는지를 검증하기 위해 (원본데이터 + 해시 함수)를 더해 보낸다.
 
하지만, 해시 함수만 사용할 경우 중간자 공격에 취약하기 때문에, **HMAC(Hash-based Message Authentication Code)** 이라는 보다 안전한 방식이 사용된다. HMAC은 메시지와 비밀키를 함께 해시 함수(원본데이터 + 해시 함수 + 비밀키)에 입력하여 인증 코드를 생성함으로써 메시지의 무결성과 송신자 인증을 동시에 제공한다. 송신자와 수신자만이 공유하는 비밀키를 사용하기 때문에, 키를 모르는 제3자는 유효한 HMAC 값을 생성할 수 없다. HMAC-MD5, HMAC-SHA256 등 다양한 해시 알고리즘과 조합하여 사용할 수 있으며, SSL/TLS, IPsec, VPN 등 많은 보안 프로토콜에서 메시지 인증을 위해 널리 활용된다.  

<br> 

## 디지털 서명 : 부인봉쇄의 필요성  
디지털 서명은 메시지 인증의 한계를 넘어 부인방지(non-repudiation) 기능을 제공하는 암호화 기술이다. HMAC이 메시지 무결성을 검증할 수 있지만, 송신자와 수신자가 동일한 비밀키를 공유하기 때문에 누가 메시지를 생성했는지 제3자가 확인할 수 없다는 한계가 존재한다.  

```
부인방지(non-repudiation)는 디지털 서명을 통해 송신자가 자신의 개인키로 메시지에 서명함으로써,
나중에 해당 메시지를 보냈다는 사실을 부인할 수 없도록 하는 보안 기능이다.
```

디지털 서명은 이 문제를 해결하기 위해 비대칭키 암호화의 특성을 활용한다. 송신자는 자신의 개인키(오직 본인만 소유)로 데이터를 암호화하여 서명을 생성하고, 수신자는 송신자의 공개키로 이 서명을 복호화하여 검증합니다. 이 과정을 통해 해당 메시지가 개인키 소유자에 의해 작성되었음을 증명할 수 있으며, 송신자는 나중에 메시지 전송 사실을 부인할 수 없게 됩니다.  
 
일반적으로 비대칭키 암호화에서 공개키를 이용하여 암호화하였다면 반대로 개인키를 가지고 암호화하여 자신의 신원을 보장한다는 것이 큰 특징이다. ( 계약서의 싸인 및 서명하는 것처럼, 자신의 개인키를 가지고 전자서명을 생성한다.)  
이러한 디지털 서명, 즉 전자서명 값을 시그니처(Signature)라고 한다.  

## X.509 & PKI
**X.509와 PKI(Public Key Infrastructure)** 는 현대 인터넷 보안의 핵심 요소로, 디지털 인증서와 공개키 암호화를 통해 안전한 보안 통신을 가능하게 한다.  
 
**X.509는 디지털 인증서의 표준 형식**이며, 인증서 소유자의 신원, 공개키, 유효기간, 발급자 정보 등을 포함한다. 이 표준화된 형식을 통해 다양한 시스템과 애플리케이션 간의 호환성을 보장한다.  
 
PKI(Public Key Infrastructure)는 이러한 디지털 인증서를 생성, 관리, 배포하는 전체 시스템과 인프라를 의미한다.  
PKI의 특징은 다음과 같다.  

PKI는 기본적으로 RSA 암호화 알고리즘을 사용한다.  
인증서 발급자(ISSUER)는 인증기관(CA, Certificate Authority)이다.  
CA가 자신의 개인키로 서명하여 스스로 인증한 인증서를 루트 인증서라고 한다.  
제3의 공인된 인증기관을 통해 공개키 배포의 신뢰성 문제를 해결한다.  
정리하자면, PKI의 주요 목적은 X.509라는 표준화된 인증서 형식을 활용하여 CA라는 인증 기관을 통해서 사용자의 공개키를 신뢰성 있게 배포하기 위한 환경을 제공하는 것이다.  
 
 
실제 구현에서는 RSA와 같은 알고리즘이 대용량 데이터 암호화에 비효율적이므로, 메시지 전체가 아닌 해시값만 암호화하는 방식을 사용합니다.  

## 6) IoT/엣지에서 무엇을 쓸까? (의사결정 가이드)
- **기본 선택(AEAD)**  
  - **ASCON-AEAD128**: NIST 경량암호 표준(2025, SP 800-232). 저자원 장치에서 **작은 코드/메모리**와 태그 인증 제공.  
  - **AES-GCM**: 보드에 **AES 하드웨어 가속**이 있으면 여전히 강력한 선택.
- **블록 암호 CTR만 우선 쓰는 기능검증**(태그 생략): **IV/nonce 재사용 금지**를 문서화·검증할 것.
- **키 관리**: 프로토타입은 임시 로딩, 제품화는 **eFUSE/OTP/SE/PUF** 중 택1.
- **TRNG/DRBG**: IV/nonce·마스킹에 필요. 보드의 RNG 품질 확인.

---

## 6) 블록 암호 운용 모드 (ECB / CBC / CTR / GCM)

| 모드 | 개념 | 장점 | 단점/주의 | 쓰임새 |
|---|---|---|---|---|
| **ECB** | 블록 독립 변환 | 구현 간단 | **패턴 노출** → 사실상 금지 | 학습/디버그 한정 |
| **CBC** | 이전 블록과 체인 + 랜덤 IV | 간단, 과거 표준 | **직렬화**, 패딩 필요, **무결성 없음** | 레거시 호환 |
| **CTR** | `KS = E(K, nonce||ctr)`, 스트림화 | 병렬화, 패딩X, 간단 | **malleable**, **nonce 재사용 금지**, MAC 필요 | 임베디드/FPGA 적합 |
| **GCM** | CTR + GHASH(태그) | **AEAD**(무결성 포함), 병렬화 | **nonce 재사용 금지**(치명적) | 범용 표준 |

> **IV/nonce 규칙**: 각 (키, nonce) 조합 **단 한 번**만 사용. GCM은 **96비트 IV** 권장.

---

## 7) AEAD (Authenticated Encryption with Associated Data)
**기밀성 + 무결성(인증 태그)** 동시 제공. AAD(헤더 등)는 암호화하지 않고 태그에만 포함.
- **대표**: **AES-GCM**, **CCM**, **ChaCha20-Poly1305**, **ASCON-AEAD**(경량 표준 계열)
- **장점**: 암호화/검증 한 번에, 구현 실수 감소
- **주의**: **(키, nonce) 재사용 금지**. 재사용 시 기밀성·무결성 모두 붕괴

---

## 8) 스트림 암호 vs 블록 암호
- **스트림 암호**: 키스트림 `KS` 생성 후 `C = P ⊕ KS`  
  - 장점: 지연 적음, 패딩 불필요, 바이트/비트 단위 처리  
  - 주의: **같은 (키, nonce)** 재사용 → 원문 누설  
  - 예: ChaCha20 (*블록암호 CTR 운용은 사실상 스트림처럼 동작*)
- **블록 암호**: 고정 블록(예: 64/128b) 단위 변환 → **모드**로 스트림화  
  - 장점: 표준/분석 풍부, HW 구현 용이  
  - 주의: **블록 크기 생일한계**: n-비트 블록이면 약 **2^(n/2)** 블록 수준에서 충돌 위험

---

## 9) Feistel vs SPN (Substitution-Permutation Network)

| 구분 | 구조 | 복호화 | 대표 |
|---|---|---|---|
| **Feistel** | 입력을 L/R로 나눠 `Lᵢ₊₁ = Rᵢ`, `Rᵢ₊₁ = Lᵢ ⊕ F(Rᵢ, Kᵢ)` | **같은 F**, **키 순서 역순** | **DES**, **SIMON**, **SIMECK/SPECK** |
| **SPN** | **S-box(비선형)** → **선형 확산(P)** 반복 | **역 S-box/역 선형층** 필요 | **AES**, **PRESENT**, **PIPO** |

- **HW 관점**  
  - Feistel: 복호가 쉽다(라운드 역함수 불필요), F 설계가 핵심  
  - SPN: **병렬 S-box + 고정 배선**으로 파이프라인/직렬화 선택 폭 큼

---

## 10) 부채널 공격(측면 채널) — 개념/대응
**개념**: 수학적 취약점이 아닌 **전력·시간·EM(전자파)·Fault** 등 물리적 누설로 키를 추정.
- **최소 대응(프로토타입)**: **상수 시간화**(분기 제거/루프 일정), **메모리 접근 패턴 고정**, **nonce 재사용 금지**
- **강화(제품)**: **마스킹(1st-order↑)**, 셔플링/디-동기화, 난수 주입, 전력 평탄화/차폐, **Fault 검출**(이중 계산·체크태그)
- **평가**: TVLA(t-test) 등 통계 시험으로 누설 유무 점검

---



## 7) 경량암호(Lightweight Crypto) 개요
**제약(면적/전력/메모리/지연)** 환경에 맞춘 대칭·AEAD·해시들. 설계 트레이드오프:
- 작은 S-box/간단 전치, 직렬화(면적↓) vs 파이프라인(처리량↑), 상태크기 최소화.
- **부채널** 대응(마스킹/타이밍 균일화) 고려.

---

## 8) 블록암호·AEAD 간단 소개 (IoT 관점)

- **PRESENT** — *경량 블록암호 (SPN)*  
  64-bit 블록, 80/128-bit 키, **31라운드**. 4-bit S-box ×16 + 비트 전치 P-레이어. HW 면적/전력 매우 작다. (아래 상세)  
- **SIMON / SIMECK** — *경량 블록암호 (Feistel/ARX)*  
  하드웨어 친화적 회전·AND·XOR로 구성. 다양한 블록/키 크기 변종이 있어 임베디드에 맞춰 선택.  
- **ASCON** — *경량 **AEAD/해시***  
  **블록암호가 아니라** 순열기반 스펀지 구조. **AEAD(태그)**와 해시/XOF 제공. NIST 경량암호 표준(2025).  
- **국산 예시** — *LEA/CHAM/HIGHT/PIPO*  
  임베디드 최적화 설계 자료가 풍부, HW 구현 레퍼런스 다수.

> 참고: 블록암호는 **모드(CTR/GCM/CCM 등)**로 운용해야 파일/스트림을 처리 가능. AEAD는 태그 포함으로 **무결성**까지.

---

## 9) PRESENT 한 장 요약 (구조·이점·주의)
- **파라미터**: 블록 64b, 키 80/128b, **31 라운드**, 최종 **AddRoundKey**(포스트 화이트닝).  
- **라운드**:  
  1) `AddRoundKey` (64b ⊕ 라운드키) →  
  2) `S-box Layer` (4b S-box 16개 병렬 적용) →  
  3) `Permutation Layer` (비트 위치 전치).  
- **키스케줄**: 라운드 상수 추가 + 회전/치환으로 라운드키 생성(PRESENT-80/128 차이 존재).  
- **장점**: **소면적/저전력**(직렬화 구현 용이), 단순 구조 → RTL 분해 쉬움.  
- **주의**: **64-bit 블록**은 대용량 스트림에서 **생일한계**가 빨리 온다. CTR/CFB 등 운용 시 **nonce/카운터 관리**를 철저히 하고, AEAD를 쓰면 더 안전.

---

## 10) HW 구현의 이득과 함정 (SoC/FPGA 관점)

**이득**
- 파이프라인/병렬화로 **고처리량·저지연**, 소프트웨어 대비 **에너지/성능 우수**, 펌웨어 노출 감소.

**함정**
- **부채널 공격**(전력/EM/타이밍/글리치) 취약:  
  - 초기: **타이밍 균일화**, 분기/메모리 패턴 고정.  
  - 개선: **마스킹/블라인딩**, 난수 주입, 전력 평탄화.  
- 키 보관/업데이트: eFUSE/OTP는 **불가역**, SE/TPM은 BOM/통합 부담.

---

## 11) PRESENT RTL 시작 체크리스트 (기능검증용)

- **모듈 분해**: `present_core`(1라운드) / `key_schedule` / `round_ctrl` / `ctr_wrapper`(선택).  
- **데이터 경로**: 64b 상태 레지스터 ↔ S-box(16×4b) ↔ P-레이어 비트 셔플.  
- **라운드 제어**: 31회 반복 + **마지막 AddRoundKey**.  
- **CTR 래퍼**(옵션): 64b nonce||counter → **재사용 금지**, 블록마다 counter++.  
- **검증**: 공개 **테스트벡터**로 블록·스트림 확인 → 파일 round-trip 테스트(평문→암→복호 동일).  
- **초기 보안 위생**: 조건문 분기 제거, 고정 지연 파이프라인, IV/nonce 기록.

---

## 12) 빠른 선택 가이드 (요약)
- **AEAD 필요(무결성 포함)**: **ASCON-AEAD128**(저자원) 또는 **AES-GCM**(HW 가속 시).  
- **기능검증(암복호만)**: **PRESENT-CTR**(간단/저자원) → IV/nonce 재사용 금지.  
- **키보관**: 프로토타입 임시 로딩 → 제품화 시 **eFUSE/OTP/SE/PUF**로 이관.

---

## 참고/추가읽기(한글 위주)
- **KISA 암호 키 관리 안내서** — 키 수명주기·보관·폐기 가이드.  
- **KISA 부채널 공격 취약성 평가방법론** — 전력/EM/타이밍 공격과 대응.  
- **PRESENT 구조/라운드/키스케줄** — 한글 특허/논문 요약.  
- **SIMON/SIMECK 개요(경량 블록암호)** — 한글 논문/요약.  
- **NIST SP 800-232 (2025)** — **ASCON 기반 경량암호 표준**(AEAD/Hash/XOF).


 -->





